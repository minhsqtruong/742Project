import os
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

########################## PARSING FUNCTIONS ###################################
def get_file_addr():
    # test_dir = input("Which baseline test do you want to parse? ")
    # coreid = input("Which core id do you want to parse?")
    test_dir = "pim-test-multicore"
    apps = [ f.path for f in os.scandir(test_dir) if f.is_dir() ]
    datas = {}
    for app in apps:
        data = [f.path for f in os.scandir(app) if f.is_dir()]
        data.sort()
        if (app.split("/")[1] == 'bfs'):
            datas['bfs'] = data
        elif (app.split("/")[1] == 'pr'):
            datas['pr'] = data
        elif (app.split("/")[1] == 'tc'):
            datas['tc'] = data

    return datas

def get_stats(addr, field, pos, coreid=None, app=None, dataset=None):
    '''
    addr: the address generated by get_file_addr() function
    field: the field we want parse the stats
    pos: position of the value of interest in the line
    app: parse by application
    dataset: parse by dataset
    '''

    # Check mutual exclusive condition
    if (app is not None and dataset is not None):
        print("Error: only parse exculsively by application or dataset \n")
        exit(-1)
    stats = {}
    # If group stats by applications
    if (app):
        dir = addr[app]
        for data in dir:
            file = data+'/stats.txt'
            if (coreid is not None):
                file = data+'/'+str(coreid)+'/stats.txt'
            with open(file) as f:
                for line in f:
                    if (field in line):
                        stats[data.split('/')[2]] = line.split()[pos]
    # If group stats by dataset
    elif (dataset):
        dir = []
        for key in addr:
            app_dir = addr[key]
            for data_dir in app_dir:
                if (data_dir.split('/')[2] == dataset):
                    dir.append(data_dir)
        for data in dir:
            with open(data+'/stats.txt') as f:
                for line in f:
                    if (field in line):
                        stats[data.split('/')[1]] = line.split()[pos]
    else:
        print("Error: you need to select either parse by app or dataset\n")
        exit(-1)
    return stats
########################## END PARSING FUNCTIONS ###############################

########################## PLOTTING FUNCTIONS ##################################
def plot_inter_bar(addr, field, apps, plottitle="Specify Title", ytitle="Specify Title", glimpse=True, max_core_id=16):

    # Get column name
    colname = []
    for app in apps:
        for dataset in addr[app]:
            colname.append(dataset.split('/')[2])
    colname = list(set(colname))
    colname.sort()

    bars = {}
    rs = {}
    for name in colname:
        rs[name] = []
        bars[name] = []

    # Populate dataframe
    for id in range(max_core_id):
        raw = get_stats(addr=addr, field=field, pos=1, coreid=id, app=app)
        for name in colname:
            bars[name].append(raw[name])

    barWidth = 0.25
    rs[colname[0]] = np.arange(len(bars[colname[0]]))
    axe = plt.subplot()
    for i in range(len(colname) - 1):
        rs[colname[i+1]] = [x + barWidth for x in rs[colname[i]]]
    for name in colname:
        axe.bar(rs[name], bars[name], width=barWidth)
    axe.legend(colname, loc=[1.01, 0.5])
    axe.set_ylim(ymin=0)
    plt.title(plottitle)
    plt.ylabel(ytitle)
    plt.show()

######################## END PLOTTING FUNCTIONS ################################

if __name__ == '__main__':

    # Get the address of the stats.txt file in each application + data combo
    addr = get_file_addr()
    plot_inter_bar(addr=addr, field="sim_seconds", apps=["pr"], plottitle="Each core vs. sim_seconds doing PR ",
            ytitle="Seconds (s)")
