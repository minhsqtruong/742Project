import os
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

########################## PARSING FUNCTIONS ###################################
def get_file_addr():
    # test_dir = input("Which test do you want to parse? ")
    test_dir = "baseline-atomic"
    apps = [ f.path for f in os.scandir(test_dir) if f.is_dir() ]
    datas = {}
    for app in apps:
        data = [f.path for f in os.scandir(app) if f.is_dir()]
        data.sort()
        if (app.split("/")[1] == 'bfs'):
            datas['bfs'] = data
        elif (app.split("/")[1] == 'pr'):
            datas['pr'] = data
        elif (app.split("/")[1] == 'tc'):
            datas['tc'] = data
    return datas

def get_stats(addr, field, pos, app=None, dataset=None):
    '''
    addr: the address generated by get_file_addr() function
    field: the field we want parse the stats
    pos: position of the value of interest in the line
    app: parse by application
    dataset: parse by dataset
    '''

    # Check mutual exclusive condition
    if (app is not None and dataset is not None):
        print("Error: only parse exculsively by application or dataset \n")
        exit(-1)
    stats = {}
    # If group stats by applications
    if (app):
        dir = addr[app]
        for data in dir:
            with open(data+'/stats.txt') as f:
                for line in f:
                    if (field in line):
                        stats[data.split('/')[2]] = line.split()[pos]
    # If group stats by dataset
    elif (dataset):
        dir = []
        for key in addr:
            app_dir = addr[key]
            for data_dir in app_dir:
                if (data_dir.split('/')[2] == dataset):
                    dir.append(data_dir)
        for data in dir:
            with open(data+'/stats.txt') as f:
                for line in f:
                    if (field in line):
                        stats[data.split('/')[1]] = line.split()[pos]
    else:
        print("Error: you need to select either parse by app or dataset\n")
        exit(-1)
    return stats
########################## END PARSING FUNCTIONS ###############################

########################## PLOTTING FUNCTIONS ##################################
def plot_table(addr, field, glimpse=True, show=False, save_dir=None):
    '''
    addr: the address generated by get_file_addr() function
    field: the field we want to form the basic table out of
    glimpse: print a part of the table in the shell
    show: plot the entire table using matplotlib
    save_dir: save the table in csv format
    '''

    colname = []

    # Get all column names
    for app in ["bfs", "pr", "tc"]:
        for dataset in addr[app]:
            colname.append(dataset.split('/')[2])
    colname = list(set(colname))
    colname.sort()
    colname.insert(0,"Application")
    # Initialize first column
    tableContent = np.array([["bfs"],["pr"],["tc"]])

    # Populate Table
    for dataset in colname[1:]:
        raw = get_stats(addr=addr, field=field, pos=1, app=None, dataset=dataset)
        if(raw == {}):
            tableContent = np.concatenate((tableContent, np.array([["n/a"],["n/a"],["n/a"]])), axis=1)
        else:
            tableContent = np.concatenate((tableContent, np.array([[float(raw['bfs'])], \
                                                                   [float(raw['pr'])], \
                                                                   [float(raw['tc'])]])), axis=1)

    df = pd.DataFrame(tableContent, columns=colname)

    if (show):
        # Generate Table
        fig, ax = plt.subplots()
        fig.patch.set_visible(False)
        ax.axis('off')
        ax.axis('tight')
        ax.table(cellText=df.values, colLabels=df.columns, loc='center', cellLoc='center')
        fig.tight_layout()
        plt.show()
    if (glimpse):
        print("Table for " + str(field))
        print(df)
    if (save_dir is not None):
        df.to_csv(save_dir+str(field)+".csv")

def plot_stackbar(addr, fields, plottitle="Specify Title", ytitle="Specify Title", H="/", glimpse=True, show=False, save_dir=None):
    '''
    addr: the address generated by get_file_addr() function
    fields: list of fields we want to stack
    plottitle: title of plot
    ytitle: title of y axis
    H: matplotlib hatching pattern
    glimpse: print a part of the table in the shell
    show: plot the entire table using matplotlib
    save_dir: save the table in csv format
    '''

    datasets = []
    # Get all dataset names
    for app in ["bfs", "pr", "tc"]:
        for dataset in addr[app]:
            datasets.append(dataset.split('/')[2])
    datasets.sort()
    datasets = list(set(datasets))

    # Initialize stacked bar dataframes
    bars = {}
    for app in ["bfs", "pr", "tc"]:
        bars[app] = {}
        for field in fields:
            bars[app][field] = []

    # Populate bars
    for app in ["bfs", "pr", "tc"]:
        for field in fields:
            raw = get_stats(addr=addr, field=field, pos=2, app=app, dataset=None)
            values = []
            for key in raw:
                if (key in datasets):
                    values.append(float(raw[key].split("%")[0]))
                else:
                    values.append(0.0)
            bars[app][field] = values

    dfall = []
    for key in bars:
        dfall.append(pd.DataFrame(bars[key], index = ["bfs", "pr", "tc"]))

    if (glimpse):
        print(dfall[0])
        print(dfall[1])
        print(dfall[2])

    # Plotting staked bars
    n_df = len(dfall)
    n_col = len(dfall[0].columns)
    n_ind = len(dfall[0].index)
    axe = plt.subplot(111)

    for df in dfall : # for each data frame
        axe = df.plot(kind="bar",
                      linewidth=0.5,
                      stacked=True,
                      ax=axe,
                      legend=False,
                      grid=False,
                      edgecolor="black")  # make bar plots

    h,l = axe.get_legend_handles_labels() # get the handles we want to modify
    for i in range(0, n_df * n_col, n_col): # len(h) = n_col * n_df
        for j, pa in enumerate(h[i:i+n_col]):
            for rect in pa.patches: # for each index
                rect.set_x(rect.get_x() + 1 / float(n_df + 1) * i / float(n_col))
                rect.set_hatch(H * int(i / n_col)) #edited part
                rect.set_width(1 / float(n_df + 1))

    axe.set_xticks((np.arange(0, 2 * n_ind, 2) + 1 / float(n_df + 1)) / 2.)
    axe.set_xticklabels(df.index, rotation = 0)
    axe.set_title(title)

    # Add invisible data to add another legend
    n=[]
    for i in range(n_df):
        n.append(axe.bar(0, 0, color="gray", hatch=H * i))

    l1 = axe.legend(h[:n_col], l[:n_col], loc=[1.01, 0.5])
    l2 = plt.legend(n, datasets, loc=[1.01, 0.1])
    axe.add_artist(l1)
    plt.ylabel(ytitle)

    if show:
        plt.show()

    if save_dir is not None:
        plt.savefig(save_dir + " " + title + " vs. " + ytitle + ".png")
######################## END PLOTTING FUNCTIONS ################################

if __name__ == '__main__':

    # Get the address of the stats.txt file in each application + data combo
    addr = get_file_addr()

    ############################## PARSING TUTORIAL ############################
    # Example: parse by applications (bfs) for sim_seconds field, whose value is
    # stored in the 1st position of the line
    # group_by_app = get_stats(addr=addr, field="sim_seconds", pos=1, app="bfs", dataset=None)
    # print(group_by_app)
    # Example: parse by dataset (germany_osm) for sim_seconds field, whose value is
    # stored in the 1st position of the line
    # group_by_dataset = get_stats(addr=addr, field="sim_seconds", pos=1, app=None, dataset="germany_osm")
    # print(group_by_dataset)
    ############################## END PARSING TUTORIAL ########################

    # Plotting metrics similar to results.txt
    plot_table(addr, "sim_seconds")
    plot_table(addr, "host_seconds")
    plot_table(addr, "sim_ticks")
    plot_table(addr, "sim_ops")

    plot_stackbar(addr, ["IntAlu", "IntMult", "IntDiv"], plottitle="Operations breakdown", ytitle="Percentage (%)", show=True)
